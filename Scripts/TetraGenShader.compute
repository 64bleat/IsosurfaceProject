/* IsoSurface Generation ======================================================
Distance Calculations
		
		Distance, or weight, calculations generate a 3D array of float values,
	that correspond to how far away the closest surface will be. When a surface
	lies between two of these points, the inverse lerp of the weights will be
	between 0 and 1. The algorithm is designed to have an expandable set
	of shapes and blend modes.

Marching Tetrahedra Algoritm

		Each cubic cell is divided into 5 tetrahedra.
	Of those tetrahedra, 0 to 2 triangles may be generated.
	Of those triangles, 0 to 6 total vertices may be generated.
	One cell will have a maximum of 30 vertices and each vertex
	must have a spot in the buffer, trianglesToAdd. It is not very space-efficient,
	but it will be condensed CPU-side before being made into meshes.

		After the 3D distance array "weights" is generated from ShapeData in
	the CalculateWeights kernel, the MarchingPentetra kernel follows
	the Marching Tetrahedra algorithm and stores vertex data to be made
	into meshes by the CPU portion of the script, TetraGen.

		Each cell lies between the points in the distance array, so
	all dimensions are 1 smaller than the distance array.

		When the inverse lerp of the weight of two points is between 0 and 1, 
	the isosurface runs between those two points and triangles will ge generated.

checkMask

		checkMask condenses the slide factors into a single int to be used
	in a switch. This allows every edge case to be quickly identified.
*/

#pragma kernel MarchingPentetra
#pragma kernel CalculateWeights

// Imports from TetraGenChunk
struct ShapeData
{
	uint shapeType;
	uint blendMode;
	float blendFactor;
	float bevelRadius;
	float4x4 worldToLocal;
	float4x4 localToWorld;
};

// Exports to TetraGenChunk
struct TriangleData
{
	float3 position;
	float3 normal;
};

//buffers (not shared between kernels)
StructuredBuffer<ShapeData> shapes;
RWStructuredBuffer<float> weights;
RWStructuredBuffer<TriangleData> trianglesToAdd;
RWStructuredBuffer<int> cellTriangleCount;

// global variables (shared between kernels)
float4x4 gridToWorldMatrix;
uint shapeCount;
int xBound, yBound, zBound;
int flipNormal = -1;
float3 cellBounds;

// Inverse Lerp specialized to find position of 0
float invLerp(float from, float to)
{
	return -from / (to - from);
}

// Normal sign is 0 when n == 0. zsign is -1 when n == 0.
int zsign(float n)
{
	return sign(sign(n) * 2 - 1);
}

// Summation used to easily convert 3d array index to 1d
uint summate(uint3 a)
{
	return a.x + a.y + a.z;
}

[numthreads(1,1,1)]
void MarchingPentetra (uint3 id : SV_DispatchThreadID)
{
	uint3 toWeightIndex = uint3(yBound * zBound, zBound, 1);
	uint3 toCellIndex = uint3((yBound - 1) * (zBound - 1), zBound - 1, 1); 
	uint cellIndex = summate(id * toCellIndex * 30);
	uint triangleStack = 0; // Stack triangles to save on sorting time

	// Mirror axis when axis index is odd
	uint3 mirror = id % 2;

	// Cube Vertex Index
	uint3 cube[] = {
		id + (uint3(0,0,0) ^ mirror),
		id + (uint3(1,0,0) ^ mirror),
		id + (uint3(1,1,0) ^ mirror),
		id + (uint3(0,1,0) ^ mirror),
		id + (uint3(0,0,1) ^ mirror),
		id + (uint3(1,0,1) ^ mirror),
		id + (uint3(1,1,1) ^ mirror),
		id + (uint3(0,1,1) ^ mirror)
	};

	// Cube Vertex Weights
	float cubeWeight[] = {
		weights[summate(cube[0] * toWeightIndex)],
		weights[summate(cube[1] * toWeightIndex)],
		weights[summate(cube[2] * toWeightIndex)],
		weights[summate(cube[3] * toWeightIndex)],
		weights[summate(cube[4] * toWeightIndex)],
		weights[summate(cube[5] * toWeightIndex)],
		weights[summate(cube[6] * toWeightIndex)],
		weights[summate(cube[7] * toWeightIndex)]
	};

	// 5 Tetrahedron Cube Vertex Index LUT
	uint4 pentetra[] = {
		uint4(0,1,2,5),
		uint4(0,2,3,7),
		uint4(0,4,5,7),
		uint4(2,5,6,7),
		uint4(0,2,5,7)
	};

	[unroll]
	for(uint t = 0; t < 5; t++)
	{
		// Tetrahedron vertices
		float3 point0 = cellBounds * cube[pentetra[t][0]];
		float3 point1 = cellBounds * cube[pentetra[t][1]];
		float3 point2 = cellBounds * cube[pentetra[t][2]];
		float3 point3 = cellBounds * cube[pentetra[t][3]];

		// Tetrahedron vertex weights
		float weight0 = cubeWeight[pentetra[t][0]];
		float weight1 = cubeWeight[pentetra[t][1]];
		float weight2 = cubeWeight[pentetra[t][2]];
		float weight3 = cubeWeight[pentetra[t][3]];

		// Tetrahedron edge intersections
		float f01 = invLerp(weight0, weight1);
		float f02 = invLerp(weight0, weight2);
		float f03 = invLerp(weight0, weight3);
		float f12 = invLerp(weight1, weight2);
		float f23 = invLerp(weight2, weight3);
		float f31 = invLerp(weight3, weight1);

		float3 tPoints[6];
		int tCount;

		uint checkMask = 0;
		checkMask |= abs(zsign(weight0) - zsign(weight1)) >> 1;
		checkMask |= abs(zsign(weight0) - zsign(weight2)) >> 0;
		checkMask |= abs(zsign(weight0) - zsign(weight3)) << 1;
		checkMask |= abs(zsign(weight1) - zsign(weight2)) << 2;
		checkMask |= abs(zsign(weight2) - zsign(weight3)) << 3;
		checkMask |= abs(zsign(weight3) - zsign(weight1)) << 4;

		switch(checkMask)
		{
			case 7: // 0: 000111 = 7
				tPoints[0] = lerp(point0, point1, f01);
                tPoints[1] = lerp(point0, point2, f02);
                tPoints[2] = lerp(point0, point3, f03);
                tPoints[4] = (point1 - point0) * weight0;
                tCount = 1;
				break;
			case 41: // 1: 101001 = 7
				tPoints[0] = lerp(point0, point1, f01);
                tPoints[1] = lerp(point1, point2, f12);
                tPoints[2] = lerp(point3, point1, f31);
                tPoints[4] = (point0 - point1) * weight1;
                tCount = 1;
                break;
			case 26: //011010
				tPoints[0] = lerp(point1, point2, f12);
                tPoints[1] = lerp(point0, point2, f02);
                tPoints[2] = lerp(point2, point3, f23);
                tPoints[4] = (point1 - point2) * weight2;
                tCount = 1;
                break;
			case 52: //110100
				tPoints[0] = lerp(point3, point1, f31);
                tPoints[1] = lerp(point2, point3, f23);
                tPoints[2] = lerp(point0, point3, f03);
                tPoints[4] = (point1 - point3) * weight3;
                tCount = 1;
                break;
			case 46: //101110
				tPoints[0] = lerp(point0, point2, f02);
                tPoints[1] = lerp(point0, point3, f03);
                tPoints[2] = lerp(point1, point2, f12);
                tPoints[3] = lerp(point3, point1, f31);
                tPoints[4] = (point2 - point0) * weight0;
                tPoints[5] = (point3 - point1) * weight1;
                tCount = 2;
                break;
			case 29: //011101
				tPoints[0] = lerp(point0, point1, f01);
                tPoints[1] = lerp(point0, point3, f03);
                tPoints[2] = lerp(point1, point2, f12);
                tPoints[3] = lerp(point2, point3, f23);
                tPoints[4] = (point1 - point0) * weight0;
                tPoints[5] = (point3 - point2) * weight2;
                tCount = 2;
                break;
			case 51: //110011
				tPoints[0] = lerp(point0, point2, f02);
                tPoints[1] = lerp(point2, point3, f23);
                tPoints[2] = lerp(point0, point1, f01);
                tPoints[3] = lerp(point3, point1, f31);
                tPoints[4] = (point0 - point2) * weight2;
                tPoints[5] = (point3 - point1) * weight1;
                tCount = 2;
                break;
			default:
				tCount = 0;
				break;	
		}

		[unroll]
		for(int tri = 1; tri <= 2; tri++)
		{
			float3 normal = cross(tPoints[tri] - tPoints[tri - 1], tPoints[tri + 1] - tPoints[tri - 1]);
			int direction = sign(dot(tPoints[tri + 3], normal)) * flipNormal;
			uint tIndex = cellIndex + (triangleStack + tri -1) * 3;
			int a = tIndex + 1 - direction;
			int b = tIndex + 1;
			int c = tIndex + 1 + direction;

			trianglesToAdd[a].position = tPoints[tri - 1];
			trianglesToAdd[b].position = tPoints[tri    ];
			trianglesToAdd[c].position = tPoints[tri + 1];
			trianglesToAdd[a].normal = trianglesToAdd[b].normal = trianglesToAdd[c].normal = normal * direction;
		}

		triangleStack += tCount;
	}

	// CellTriangleCount has 30x fewer indeces than trianglesToAdd;
	cellTriangleCount[cellIndex / 30] = triangleStack;
}

/* SHAPES =====================================================================
	These are signed distance formulas, specialized to take into account the 
	Transform of the GameObject in which the shape data is derived from.
	Sacrifices the efficiency for customizeability.
*/
float sphere(float3 worldPosition, float4x4 worldToLocal, float4x4 localToWorld)
{
	float3 localPosition = mul(worldToLocal, float4(worldPosition, 1)).xyz;
	float3 closestPosition = normalize(localPosition);
	float3 worldCenter = mul(localToWorld, float4(0, 0, 0, 1)).xyz;
	float newWeight = distance(worldPosition, worldCenter)
	                - distance(mul(localToWorld, float4(closestPosition, 1)).xyz, worldCenter);

	return newWeight;
}

float box(float3 worldPosition, float4x4 worldToLocal, float4x4 localToWorld, float bevelRadius)
{
	float3 localPosition = mul(worldToLocal, float4(worldPosition, 1)).xyz;
	float3 q = abs(localPosition) - 0.5;

	return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - bevelRadius;
}

float plane(float3 worldPosition, float4x4 worldToLocal, float4x4 localToWorld)
{
	float3 localPosition = mul(worldToLocal, float4(worldPosition, 1)).xyz;
	float3 worldPoint = mul(localToWorld, float4(0, 0, 0, 1)).xyz;
	float3 worldUp = mul(localToWorld, float4(0, 1, 0, 1)).xyz;
	float3 worldProjected = mul(localToWorld, float4(0, localPosition.y, 0, 1)).xyz;

	return sign(dot(worldUp, worldProjected - worldPoint)) * distance(worldProjected, worldPoint);
}

// BLEND MODES ================================================================
float Union(float d1, float d2)
{
	return min(d1, d2);
}

float Subtraction(float d1, float d2)
{
	return max(-d2, d1);
}

float smooth(float d1, float d2, float k)
{
	if(k <= 0)
		return Union(d1, d2);

	float h = max(k - abs(-d2 + d1), 0) / k;

	return min(d1, d2) - pow(h, 3) * k / 6;
}

float smoothUnion(float d1, float d2, float k)
{
	if(k <= 0)
		return Union(d1, d2);

	float h = clamp(0.5f + 0.5f * (d2 - d1) / k, 0.0, 1.0);
	return lerp(d2, d1, h) - k * h * (1.0 - h);
}

float intersection(float d1, float d2)
{
	return max(d1, d2);
}

/* CALCULATE WEIGHTS ==========================================================
	Switch cases coincide with the enums in TetraGenShape.
*/
[numthreads(1,1,1)]
void CalculateWeights (uint3 id : SV_DispatchThreadID)
{
	float3 gridPosition = float3(cellBounds.x * id.x, cellBounds.y * id.y, cellBounds.z * id.z);
	float3 worldPosition = mul(gridToWorldMatrix, float4(gridPosition, 1)).xyz;
	float weight = 0;
	float newWeight;
	uint s;

	for(s = 0; s < shapeCount; s++)
	{
		switch(shapes[s].shapeType)
		{
			case 0: //sphere
				newWeight = sphere(worldPosition, shapes[s].worldToLocal, shapes[s].localToWorld);
				break;
			case 1: //box
				newWeight = box(worldPosition, shapes[s].worldToLocal, shapes[s].localToWorld, shapes[s].bevelRadius);
				break;
			case 2: //plane
				newWeight = plane(worldPosition, shapes[s].worldToLocal, shapes[s].localToWorld);
				break;
			default:
				newWeight = 0;
				break;
		}

		// First shape has no shapes to blend with :(
		if(s == 0)
			weight = newWeight;
		else 
			switch(shapes[s].blendMode)
			{
				case 0: //Union
					weight = Union(weight, newWeight);
					break;
				case 1: //Subtraction
					weight = Subtraction(weight, newWeight);
					break;
				case 2: //smooth
					weight = smooth(weight, newWeight, shapes[s].blendFactor);
					break;
				case 3: //smoothUnion
					weight = smoothUnion(weight, newWeight, shapes[s].blendFactor);
					break;
				case 4: //intersection
					weight = intersection(weight, newWeight);
					break;
				case 5: //repel
					weight = 2 * Union(weight, newWeight) - smoothUnion(weight, newWeight, shapes[s].blendFactor);
					break;
				case 6: // Lerp
					weight = lerp(weight, Union(weight, newWeight), shapes[s].blendFactor);
					break;
				default:
					weight = newWeight;
					break;
			}
	}

	weights[id.x * yBound * zBound + id.y * zBound + id.z] = weight;
}

/*
Leaving the old algorith here for now in case any new bugs arise.

[numthreads(1,1,1)]
void MarchingTetrahedra (uint3 id : SV_DispatchThreadID)
{
	uint3 toWeightIndex = uint3(yBound * zBound, zBound, 1);
	uint3 mirror = id * 0;//% 2;

	//0-6 rotate the 6-7 axis counter-clockwise, loops with % 6
	uint3 cube[] = {
		id + (uint3(0,0,1) ^ mirror),
		id + (uint3(0,1,1) ^ mirror),
		id + (uint3(0,1,0) ^ mirror),
		id + (uint3(1,1,0) ^ mirror),
		id + (uint3(1,0,0) ^ mirror),
		id + (uint3(1,0,1) ^ mirror),
		id + (uint3(0,0,0) ^ mirror),
		id + (uint3(1,1,1) ^ mirror)
	};

	float cubeWeight[] = {
		weights[summate(cube[0] * toWeightIndex)],
		weights[summate(cube[1] * toWeightIndex)],
		weights[summate(cube[2] * toWeightIndex)],
		weights[summate(cube[3] * toWeightIndex)],
		weights[summate(cube[4] * toWeightIndex)],
		weights[summate(cube[5] * toWeightIndex)],
		weights[summate(cube[6] * toWeightIndex)],
		weights[summate(cube[7] * toWeightIndex)]
	};

	[unroll]
	for(uint t = 0; t < 6; t++)
	{
		float u = (t + 1) % 6;

		float3 point0 = cellBounds * cube[6];
		float3 point1 = cellBounds * cube[t];
		float3 point2 = cellBounds * cube[u];
		float3 point3 = cellBounds * cube[7];

		float weight0 = cubeWeight[6];
		float weight1 = cubeWeight[t];
		float weight2 = cubeWeight[u];
		float weight3 = cubeWeight[7];

		float f01 = invLerp(weight0, weight1);
		float f02 = invLerp(weight0, weight2);
		float f03 = invLerp(weight0, weight3);
		float f12 = invLerp(weight1, weight2);
		float f23 = invLerp(weight2, weight3);
		float f31 = invLerp(weight3, weight1);

		float3 tPoints[6];
		int tCount;

		uint checkMask = 0;
		checkMask |= abs(zsign(weight0) - zsign(weight1)) >> 1;
		checkMask |= abs(zsign(weight0) - zsign(weight2)) >> 0;
		checkMask |= abs(zsign(weight0) - zsign(weight3)) << 1;
		checkMask |= abs(zsign(weight1) - zsign(weight2)) << 2;
		checkMask |= abs(zsign(weight2) - zsign(weight3)) << 3;
		checkMask |= abs(zsign(weight3) - zsign(weight1)) << 4;

		switch(checkMask)
		{
			case 7: // 0: 000111 = 7
				tPoints[0] = lerp(point0, point1, f01);
                tPoints[1] = lerp(point0, point2, f02);
                tPoints[2] = lerp(point0, point3, f03);
                tPoints[4] = (point1 - point0) * weight0;
                tCount = 1;
				break;
			case 41: // 1: 101001 = 7
				tPoints[0] = lerp(point0, point1, f01);
                tPoints[1] = lerp(point1, point2, f12);
                tPoints[2] = lerp(point3, point1, f31);
                tPoints[4] = (point0 - point1) * weight1;
                tCount = 1;
                break;
			case 26: //011010
				tPoints[0] = lerp(point1, point2, f12);
                tPoints[1] = lerp(point0, point2, f02);
                tPoints[2] = lerp(point2, point3, f23);
                tPoints[4] = (point1 - point2) * weight2;
                tCount = 1;
                break;
			case 52: //110100
				tPoints[0] = lerp(point3, point1, f31);
                tPoints[1] = lerp(point2, point3, f23);
                tPoints[2] = lerp(point0, point3, f03);
                tPoints[4] = (point1 - point3) * weight3;
                tCount = 1;
                break;
			case 46: //101110
				tPoints[0] = lerp(point0, point2, f02);
                tPoints[1] = lerp(point0, point3, f03);
                tPoints[2] = lerp(point1, point2, f12);
                tPoints[3] = lerp(point3, point1, f31);
                tPoints[4] = (point2 - point0) * weight0;
                tPoints[5] = (point3 - point1) * weight1;
                tCount = 2;
                break;
			case 29: //011101
				tPoints[0] = lerp(point0, point1, f01);
                tPoints[1] = lerp(point0, point3, f03);
                tPoints[2] = lerp(point1, point2, f12);
                tPoints[3] = lerp(point2, point3, f23);
                tPoints[4] = (point1 - point0) * weight0;
                tPoints[5] = (point3 - point2) * weight2;
                tCount = 2;
                break;
			case 51: //110011
				tPoints[0] = lerp(point0, point2, f02);
                tPoints[1] = lerp(point2, point3, f23);
                tPoints[2] = lerp(point0, point1, f01);
                tPoints[3] = lerp(point3, point1, f31);
                tPoints[4] = (point0 - point2) * weight2;
                tPoints[5] = (point3 - point1) * weight1;
                tCount = 2;
                break;
			default:
				tCount = 0;
				break;	
		}

		for(int tri = 1; tri <= 2; tri++)
		{
			int tIndex = (id.x) * (yBound - 1) * (zBound - 1) * 36   //32 xVerts
					   + (id.y) * (zBound - 1) * 36				     //32 yVerts
					   + (id.z) * 36								 //32 zverts
					   + t * 6										 //6  tetras 
					   + (tri - 1) * 3;								 //6  vertices, start at +0 and +3

			trianglesToAdd[tIndex].position = float3(0,0,0);
			trianglesToAdd[tIndex + 1].position = float3(0,0,0);
			trianglesToAdd[tIndex + 2].position = float3(0,0,0);

			if(tri <= tCount)
			{
				float3 normal = cross(tPoints[tri] - tPoints[tri - 1], tPoints[tri + 1] - tPoints[tri - 1]);
				int direction = sign(dot(tPoints[tri + 3], normal)) * flipNormal;
			
				int a = tIndex + 1 - direction;
				int b = tIndex + 1;
				int c = tIndex + 1 + direction;

				trianglesToAdd[a].position = tPoints[tri - 1];
				trianglesToAdd[b].position = tPoints[tri    ];
				trianglesToAdd[c].position = tPoints[tri + 1];
				trianglesToAdd[a].normal = trianglesToAdd[b].normal = trianglesToAdd[c].normal = normal * direction;
			}
		}
	}
}*/
