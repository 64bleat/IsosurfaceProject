using System.Collections.Generic;
using UnityEngine;

namespace TetraGen
{
    /// <summary>
    ///     One chunk of TetraGen isosurface.
    ///     Generated by TetraGenMaster.
    /// </summary>
    [DisallowMultipleComponent]
    public class TetraGenChunk : MonoBehaviour
    {
        public ComputeShader tetraComputer;
        public MeshFilter meshTemplate;

        private TetraGenMaster master;
        private bool realtimeReady = false;
        private ShapeData[] shapeData;
        private TriangleData[] chunkTriangleData;
        private uint[] chunkCellTriangleCount;
        private Vector3[] chunkVertices;
        private Vector3[] chunkNormals;
        private int meshKernel;
        private int weightKernel;
        private ComputeBuffer weightBuffer;
        private ComputeBuffer triangleBuffer;
        private ComputeBuffer cellBuffer;
        private ComputeBuffer shapeBuffer;

        private readonly List<GameObject> subChunks = new List<GameObject>();

        // Data to be computed by and retrieved from tetraComputer
        private struct TriangleData
        {
            public Vector3 position;    // float * 3
            public Vector3 normal;      // float * 3
        }

        private void OnDestroy()
        {
            // Ensure buffers are closed
            if (realtimeReady)
                GenerationEnd();
        }

        public void GenerationStart()
        {
            master = GetComponentInParent<TetraGenMaster>();

            int cellBufferLength = master.cellCount.x * master.cellCount.y * master.cellCount.z;
            int vertexBufferLength = cellBufferLength * 30;
            int weightBufferLength = (master.cellCount.x + 1) * (master.cellCount.y + 1) * (master.cellCount.z + 1);

            chunkTriangleData = new TriangleData[vertexBufferLength];
            chunkCellTriangleCount = new uint[cellBufferLength];
            chunkVertices = new Vector3[vertexBufferLength];
            chunkNormals = new Vector3[vertexBufferLength];

            meshKernel = tetraComputer.FindKernel("MarchingPentetra");
            weightKernel = tetraComputer.FindKernel("CalculateWeights");

            weightBuffer = new ComputeBuffer(weightBufferLength, sizeof(float));
            triangleBuffer = new ComputeBuffer(vertexBufferLength, sizeof(float) * 6);
            cellBuffer = new ComputeBuffer(cellBufferLength, sizeof(uint));

            realtimeReady = true;
        }

        public void GenerationUpdateNewShapeData(ShapeData[] shapeData, bool collisionEnabled = true)
        {
            this.shapeData = shapeData;
            GenerationUpdate();
        }

        private void GenerationUpdate()
        {
            if (!realtimeReady)
                GenerationStart();

            int vertexCount = 0;
            int meshCount;

            // Initialize shader variables.
            shapeBuffer = new ComputeBuffer(shapeData.Length, sizeof(uint) * 2 + sizeof(float) * 34);
            shapeBuffer.SetData(shapeData);
            tetraComputer.SetBuffer(weightKernel, "shapes", shapeBuffer);
            tetraComputer.SetBuffer(meshKernel, "weights", weightBuffer);
            tetraComputer.SetBuffer(weightKernel, "weights", weightBuffer);
            tetraComputer.SetBuffer(meshKernel, "trianglesToAdd", triangleBuffer);
            tetraComputer.SetBuffer(meshKernel, "cellTriangleCount", cellBuffer);
            tetraComputer.SetMatrix("gridToWorldMatrix", transform.localToWorldMatrix);
            tetraComputer.SetInt("shapeCount", shapeData.Length);
            tetraComputer.SetInt("xBound", master.cellCount.x + 1);
            tetraComputer.SetInt("yBound", master.cellCount.y + 1);
            tetraComputer.SetInt("zBound", master.cellCount.z + 1);
            tetraComputer.SetInt("flipNormal", master.flipNormals ? 1 : -1);
            tetraComputer.SetFloats("cellBounds", new float[] { master.cellScale.x, master.cellScale.y, master.cellScale.z });

            // Run shader kernels
            tetraComputer.Dispatch(weightKernel, master.cellCount.x + 1, master.cellCount.y + 1, master.cellCount.z + 1);
            tetraComputer.Dispatch(meshKernel, master.cellCount.x, master.cellCount.y, master.cellCount.z);

            // Get triangle data from GPU. Time consuming!
            triangleBuffer.GetData(chunkTriangleData);
            cellBuffer.GetData(chunkCellTriangleCount);

            // Shape buffer can change every frame, so it must be released here.
            shapeBuffer.Release();

            for (int cell = 0; cell < chunkCellTriangleCount.Length; cell++)// += 30)
                for (int tri = 0; tri < chunkCellTriangleCount[cell]; tri++)
                    for (int t = tri * 3, v = 0; v < 3; v++, vertexCount++)
                    {
                        chunkVertices[vertexCount] = chunkTriangleData[cell * 30 + t + v].position;
                        chunkNormals[vertexCount] = chunkTriangleData[cell * 30 + t + v].normal;
                    }

            // Count how many meshes are needed. Each mesh may only have 65535 verts.
            meshCount = Mathf.CeilToInt(vertexCount / 65535f);

            // Deactivate unneeded meshes. Meshes are only instantiated once. 
            for (int i = 0; i < subChunks.Count; i++)
                subChunks[i].SetActive(i < meshCount);

            // Mesh Generation
            for (int i = 0; i < meshCount; i++)
            {
                int startIndex = i * 65535; // 65535 is the maximum mesh vertex count
                int endIndex = Mathf.Min(vertexCount, startIndex + 65535);
                int meshSize = endIndex - startIndex;
                Vector3[] mVertices = new Vector3[meshSize];
                Vector3[] mNormals = new Vector3[meshSize];
                int[] mTriangles = new int[meshSize];

                // Disperse chunk data into individual meshes
                for (int v = startIndex; v < endIndex; v++)
                {
                    mVertices[v - startIndex] = chunkVertices[v];
                    mNormals[v - startIndex] = chunkNormals[v];
                    mTriangles[v - startIndex] = v - startIndex;
                }

                // Finally, make the mesh.
                GameObject mo = i < subChunks.Count ? subChunks[i] : Instantiate(meshTemplate.gameObject, transform);
                MeshFilter mf = mo.GetComponent<MeshFilter>();
                MeshCollider mc = master.generateCollision ? mo.GetComponent<MeshCollider>() : null;
                Mesh mesh = mf.sharedMesh ? mf.sharedMesh : new Mesh();
                Vector3 boundScale = new Vector3(
                    master.cellCount.x * master.cellScale.x,
                    master.cellCount.y * master.cellScale.z,
                    master.cellCount.z * master.cellScale.z);

                mesh.Clear();
                mesh.vertices = mVertices;
                mesh.normals = mNormals;
                mesh.triangles = mTriangles;
                mesh.bounds = new Bounds(boundScale / 2, boundScale);
                mesh.name = mo.name = "Generated Mesh " + i;
                mf.sharedMesh = mesh;

                if (mc && mc.enabled)
                    mc.sharedMesh = mesh;

                // Add the mesh to list if it isn't already there.
                if (i >= subChunks.Count)
                    subChunks.Add(mo);
            }
        }

        public void GenerationEnd()
        {
            if (realtimeReady)
            {
                chunkTriangleData = null;
                chunkVertices = null;
                chunkNormals = null;
                weightBuffer.Release();
                triangleBuffer.Release();
                cellBuffer.Release();
                realtimeReady = false;
            }
        }
    }
}
